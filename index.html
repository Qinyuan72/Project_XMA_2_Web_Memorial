<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Project_XMA</title>
  <style>
    /* 全屏黑底，白字，隐藏主滚动条 */
    html, body {
      margin: 0; 
      padding: 0;
      width: 100%; 
      height: 100%;
      background: #000;
      color: #fff;
      font-family: Arial, sans-serif;
      overflow: hidden;
    }

    /* PC 顶部淡出层（只PC显示） */
    #topBlur {
      position: absolute;
      top: 0; left: 0;
      width: 100%;
      height: 4rem;
      pointer-events: none;
      background: linear-gradient(to bottom, rgba(0,0,0,1), rgba(0,0,0,0));
      z-index: 9999;
      display: none; /* PC端显示,移动端隐藏 */
    }

    /* 移动端的顶部和底部淡出层（只移动端显示） */
    #topMobileBlur, #bottomMobileBlur {
      display: none;
      position: absolute;
      left: 0; width: 100%;
      pointer-events: none;
      z-index: 9999;
    }
    /* 顶部 10% 淡出 */
    #topMobileBlur {
      top: 0;
      height: 10vh;
      background: linear-gradient(to bottom, rgba(0,0,0,1), rgba(0,0,0,0));
    }
    /* 底部 10% 淡出 */
    #bottomMobileBlur {
      bottom: 0;
      height: 10vh;
      background: linear-gradient(to top, rgba(0,0,0,1), rgba(0,0,0,0));
    }

    /* 容器 #output，PC与移动端布局不同 */
    #output {
      position: absolute;
      transition: top 1s ease, transform 1s ease;
      overflow-y: auto;
      scroll-behavior: smooth;
      -ms-overflow-style: none;
      scrollbar-width: none;
    }
    /* 隐藏滚动条 (WebKit) */
    #output::-webkit-scrollbar {
      width: 0; 
      background: transparent;
    }
    #output:hover::-webkit-scrollbar {
      width: 6px; 
    }
    #output:hover::-webkit-scrollbar-thumb {
      background: #666; 
      border-radius: 3px;
    }
    #output:hover::-webkit-scrollbar-track {
      background: transparent;
    }

    /* PC 布局 */
    @media (min-width: 769px) {
      #topBlur {
        display: block; /* PC端显示顶部淡出 */
      }
      #topMobileBlur, #bottomMobileBlur {
        display: none; /* 移动端淡出层对PC隐藏 */
      }
      #output {
        top: 50%; 
        left: 50%;
        transform: translate(-50%, -50%);
        width: 60%;
        font-size: 1.92rem;  
        line-height: 1.4;
        text-align: center;
        max-height: 50vh;
        margin-top: 4rem; /* 让内容可滚到顶部遮罩下 */
      }
    }

    /* 移动端 布局 */
    @media (max-width: 768px) {
      #topBlur {
        display: none;
      }
      #topMobileBlur, #bottomMobileBlur {
        display: block; /* 移动端显示上下10%淡出层 */
      }

      #output {
        top: 10%;
        left: 50%;
        transform: translateX(-50%);
        width: 90%;
        height: 80vh;        
        font-size: 1.2rem;    
        line-height: 1.4;
        text-align: center;
        margin-top: 0;        
      }
    }

    /* 打印完组后容器移到下方70% */
    #output.moveDown {
      top: 70%;
      transform: translate(-50%, -70%);
    }

    /* 对话行: 无淡出动画，但我们会对其文本节点做Range检测 */
    .dialog-line {
      margin-bottom: 1rem;
      border-bottom: 1px solid #333;
      padding-bottom: 0.5rem;
      white-space: pre-wrap;
    }

    /* 闪烁光标 */
    .cursor {
      display: inline-block;
      width: 0;
      overflow: visible;
      margin-left: 3px;
      vertical-align: bottom;
      animation: blink-caret 0.2s step-end infinite alternate;
    }
    .cursor::after {
      content: "|";
      color: #fdd835;
    }
    @keyframes blink-caret {
      0%   { opacity: 1; }
      100% { opacity: 0; }
    }

    /* 加粗时使用的强调色 */
    strong {
      color: #fdd835;
    }
  </style>
</head>
<body>
  <!-- PC顶部淡出 -->
  <div id="topBlur"></div>
  <!-- 移动端顶部/底部10%淡出层 -->
  <div id="topMobileBlur"></div>
  <div id="bottomMobileBlur"></div>

  <!-- 主容器 -->
  <div id="output">Loading data...</div>

  <script>
    // ========== 打字机 & 滚动控制 参数 ==========
    const TYPING_INTERVAL = 35;
    const EXTRA_CURSOR_TIME = 500; 
    const LINE_DISPLAY_TIME = 1500;
    const MANUAL_SCROLL_TIMEOUT = 3000; 
    // 用于行亮度: 距顶部 < fadeDistance => brightness 1->0
    const fadeDistance = 100;

    let globalData = null;
    let outputDiv = null;
    let lastGroupName = null;

    let manualScrolling = false;
    let lastUserInteraction = 0;

    window.onload = () => {
      fetchAndDisplayData();

      // 监听容器的滚动 => 暂停自动滚动 + 做“实际折行亮度”检测
      outputDiv = document.getElementById('output');
      outputDiv.addEventListener('scroll', () => {
        manualScrolling = true;
        lastUserInteraction = Date.now();
        onScrollBrightness();
      }, { passive:true });

      // 每秒检查 => 3秒无操作则恢复自动滚动
      setInterval(() => {
        if (manualScrolling && (Date.now() - lastUserInteraction) >= MANUAL_SCROLL_TIMEOUT) {
          manualScrolling = false;
        }
      }, 1000);
    };

    /* 拉取 JSON 并初始化 */
    async function fetchAndDisplayData(){
      try {
        const response = await fetch('Data/Chat_JSON/dialog_data.json');
        if(!response.ok){
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const rawData = await response.json();

        // 收集 group
        const allGroups=new Set();
        if(rawData.dialogs && Array.isArray(rawData.dialogs)){
          rawData.dialogs.forEach(d=>{
            if(d.group) allGroups.add(d.group);
          });
        }
        globalData = {
          dialogs: rawData.dialogs||[],
          groups: Array.from(allGroups)
        };

        outputDiv= document.getElementById('output');
        if(!globalData.groups || globalData.groups.length===0){
          outputDiv.innerText='No groups available.';
          return;
        }
        startNewGroup();
      } catch(e){
        console.error('Error loading data:', e);
        outputDiv.innerText='Error loading data.';
      }
    }

    // 随机选组,尽量不重复
    function pickRandomGroup(data){
      const groups=data.groups;
      if(!groups || groups.length===0) return null;
      if(groups.length===1) return groups[0];

      let randomGroup=null, attempts=10;
      while(attempts>0){
        const candidate= groups[Math.floor(Math.random()*groups.length)];
        if(candidate!==lastGroupName){
          randomGroup=candidate; 
          break;
        }
        attempts--;
      }
      if(!randomGroup){
        randomGroup= groups[Math.floor(Math.random()*groups.length)];
      }
      lastGroupName= randomGroup;
      return randomGroup;
    }

    // 开始打印 group
    function startNewGroup(){
      outputDiv.classList.remove('moveDown');
      outputDiv.innerHTML='';
      const groupName= pickRandomGroup(globalData);
      if(!groupName){
        outputDiv.innerText='No valid group found.';
        return;
      }
      showGroup(groupName);
    }

    // 依次打印 group
    function showGroup(groupName){
      const matched= globalData.dialogs.filter(d=> d.group===groupName);
      if(!matched.length){
        outputDiv.innerText=`No dialogs found for group: ${groupName}`;
        return;
      }
      const lines= matched.map(d=> `#${d.group_sequence_no} (${d.tag}) ${d.content}`);
      let idx=0;

      function showNextLine(){
        if(idx>=lines.length){
          // 打印完 => 容器下移
          outputDiv.classList.add('moveDown');
          setTimeout(()=> startNewGroup(),2000);
          return;
        }
        const lineText= lines[idx++];
        typeLine(lineText, outputDiv, ()=>{
          setTimeout(()=>{
            setTimeout(showNextLine, LINE_DISPLAY_TIME);
          },0);
        });
      }
      showNextLine();
    }

    // 逐字打印
    function typeLine(lineText, containerEl, onComplete){
      let charIndex=0;
      const lineDiv=document.createElement('div');
      lineDiv.className='dialog-line';
      containerEl.appendChild(lineDiv);

      function typeChar(){
        if(charIndex<= lineText.length){
          const typed= lineText.slice(0,charIndex);
          lineDiv.innerHTML= applyBoldFormatting(typed) + '<span class="cursor"></span>';
          charIndex++;
          if(!manualScrolling){
            containerEl.scrollTop= containerEl.scrollHeight;
          }
          setTimeout(typeChar,TYPING_INTERVAL);
        } else {
          setTimeout(()=>{
            lineDiv.innerHTML= applyBoldFormatting(lineText);
            if(!manualScrolling){
              containerEl.scrollTop= containerEl.scrollHeight;
            }
            onComplete&&onComplete();
          },EXTRA_CURSOR_TIME);
        }
      }
      typeChar();
    }

    // 加粗转换：**xx** => <strong>xx</strong>
    function applyBoldFormatting(text){
      return text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
    }

    // 当容器滚动时:用 Range 检测实际折行 => 找到离顶部最近的行 => brightness(1->0)
    function onScrollBrightness(){
      const container = outputDiv;
      const paragraphs = container.querySelectorAll('.dialog-line');

      if(!paragraphs.length) return;

      let candidateRect = null;
      let minDist = Infinity;

      // 遍历 .dialog-line 内所有文本节点 => 逐字符 => getClientRects()
      paragraphs.forEach(par => {
        let textNodes = getTextNodes(par);
        textNodes.forEach(node => {
          let range = document.createRange();
          for(let i=0; i< node.textContent.length; i++){
            range.setStart(node, i);
            range.setEnd(node, i+1);
            const rects = range.getClientRects();
            for(let r of rects){
              // 计算相对 container顶部的距离
              const cRect = container.getBoundingClientRect();
              let lineTop = r.top - cRect.top + container.scrollTop;
              let dist = Math.abs(lineTop - container.scrollTop);
              if(dist<minDist){
                minDist=dist;
                candidateRect=r;
              }
            }
          }
        });
      });

      if(!candidateRect) return;

      // ratio = 1->0
      let ratio = 1 - (minDist/fadeDistance);
      if(ratio<0) ratio=0;
      if(ratio>1) ratio=1;

      // 这里演示：在 candidateRect 的那部分上做一个 overlay
      // 或者直接调节 candidateRect对应的文本“亮度”
      // 由于实际折行只是 DOMRect，不是一个独立元素
      // => 需 overlay 方式 or “改变这个 textNode 的 color/...
      // 简化: 先放个 overlay

      // 先移除旧 overlay
      let oldOverlay = document.getElementById('lineOverlay');
      if(oldOverlay) oldOverlay.remove();

      let overlay = document.createElement('div');
      overlay.id = 'lineOverlay';
      overlay.style.position='absolute';
      overlay.style.pointerEvents='none';
      overlay.style.zIndex='9999';
      overlay.style.background = `rgba(255,255,0,${ratio*0.3})`;
      // 定位到 container内
      let cRect = container.getBoundingClientRect();
      let topInCont = candidateRect.top - cRect.top + container.scrollTop;
      let leftInCont= candidateRect.left- cRect.left+ container.scrollLeft;
      overlay.style.top = topInCont+'px';
      overlay.style.left= leftInCont+'px';
      overlay.style.width= candidateRect.width+'px';
      overlay.style.height=candidateRect.height+'px';
      container.appendChild(overlay);
    }

    // 小函数：获取一个元素内所有 textNode
    function getTextNodes(el){
      let res=[];
      (function recurse(node){
        if(node.nodeType===3){
          res.push(node);
        } else {
          node.childNodes.forEach(recurse);
        }
      })(el);
      return res;
    }

  </script>
</body>
</html>
